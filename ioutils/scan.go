package ioutils

import (
	"bufio"
	"bytes"
	"errors"
	"io"
	"math"

	goutils "github.com/zdz1715/go-utils/goutils"
)

// ReadLineFunc read the io.Reader line by line and call f(c) to process each line of data
func ReadLineFunc(reader io.Reader, f func(num int, line string) bool) error {
	scanner := bufio.NewScanner(reader)
	num := 0
	for scanner.Scan() {
		num++
		if !f(num, goutils.BytesToString(scanner.Bytes())) {
			break
		}
	}
	return scanner.Err()
}

var (
	ErrTooLong         = errors.New("token too long")
	ErrNegativeAdvance = errors.New("SplitFunc returns negative advance count")
	ErrAdvanceTooFar   = errors.New("SplitFunc returns advance count beyond input")
	ErrBadReadCount    = errors.New("read returned impossible count")
)

// ForwardScanner scan forward based on specified last position
type ForwardScanner struct {
	r                io.ReaderAt
	startBufSize     int
	maxScanTokenSize int

	last    int64 // Read position
	cutLen  int   // Length to be cut
	readLen int   // Read length in buf.

	token   []byte // Last token returned by split.
	buf     []byte
	initBuf bool
	done    bool
	err     error
}

func NewForwardScanner(r io.ReaderAt, last int64) *ForwardScanner {
	return &ForwardScanner{
		r:                r,
		last:             last,
		maxScanTokenSize: bufio.MaxScanTokenSize,
		startBufSize:     4096, // Size of initial allocation for buffer.
	}
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s *ForwardScanner) Bytes() []byte {
	return s.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (s *ForwardScanner) Text() string {
	return goutils.BytesToString(s.token)
}

// advance consumes n bytes of the buffer. It reports whether the advance was legal.
func (s *ForwardScanner) advance(n int) bool {
	if n < 0 {
		s.setErr(ErrNegativeAdvance)
		return false
	}
	if n > s.cutLen {
		s.setErr(ErrAdvanceTooFar)
		return false
	}
	s.cutLen -= n
	return true
}

func (s *ForwardScanner) Scan() bool {
	if s.done {
		return false
	}
	for {
		if s.cutLen > 0 || s.err != nil {
			advance, token, err := s.scanLines(s.buf[:s.cutLen], s.err != nil)
			if err != nil {
				// 最后一个
				if errors.Is(err, bufio.ErrFinalToken) {
					s.token = token
					s.done = true
					return true
				}
				s.setErr(err)
				return false
			}

			if !s.advance(advance) {
				return false
			}
			s.token = token
			if token != nil {
				return true
			}
		}

		// We cannot generate a token with what we are holding.
		// If we've already hit EOF or an I/O error, we are done.
		if s.err != nil {
			// Shut it down.
			return false
		}

		// Must read more data.
		// First, shift data to ending of buffer if there's lots of empty space
		// or space is needed.
		//if s.initBuf && s.cutLen <= len(s.buf)/2 {
		//	//s.readLen = len(s.buf) - s.cutLen
		//	//newBuf := make([]byte, s.readLen, len(s.buf))
		//	//if s.cutLen > 0 {
		//	//	newBuf = append(newBuf, s.buf[:s.readLen]...)
		//	//}
		//	//s.buf = newBuf
		//	s.buf = s.buf[:s.cutLen]
		//}

		if s.initBuf && s.cutLen == 0 {
			s.readLen = len(s.buf)
		}

		// Is the buffer full? If so, resize.
		if !s.initBuf || s.cutLen == len(s.buf) {
			// Guarantee no overflow in the resize multiplication below.
			if len(s.buf) >= s.maxScanTokenSize || len(s.buf) > math.MaxInt/2 {
				s.err = ErrTooLong
				return false
			}
			newSize := len(s.buf) * 2
			if newSize == 0 { // first init
				newSize = s.startBufSize
				s.initBuf = true
			}
			if newSize > int(s.last) {
				newSize = int(s.last) + len(s.buf)
			}
			if newSize > s.maxScanTokenSize {
				newSize = s.maxScanTokenSize
			}
			s.readLen = newSize - len(s.buf)
			newBuf := make([]byte, s.readLen, newSize)
			newBuf = append(newBuf, s.buf...)
			s.buf = newBuf
		}

		s.last -= int64(s.readLen - s.cutLen)

		if s.last < 0 {
			s.last = 0
		}

		for loop := 0; ; {
			n, err := s.r.ReadAt(s.buf[:s.readLen-s.cutLen], s.last)
			// 确保读取完整
			if n < 0 || len(s.buf[:s.readLen-s.cutLen]) < n {
				s.setErr(ErrBadReadCount)
				break
			}
			s.cutLen += n
			if err != nil {
				s.setErr(err)
				break
			}
			// 读取到首位说明
			if s.last == 0 {
				s.setErr(io.EOF)
				break
			}
			if n > 0 {
				break
			}
			loop++
			if loop > 100 {
				s.setErr(io.ErrNoProgress)
				break
			}
		}
	}
}

func (s *ForwardScanner) Err() error {
	if s.err == io.EOF {
		return nil
	}
	return s.err
}

// setErr records the first error encountered.
func (s *ForwardScanner) setErr(err error) {
	if s.err == nil || s.err == io.EOF {
		s.err = err
	}
}

func (s *ForwardScanner) scanLines(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	if i := bytes.LastIndexByte(data, '\n'); i >= 0 {
		// We have a full newline-terminated line.
		return len(data) - i, DropCR(data[i+1:]), nil
	}
	// If we're at EOF, we have a final, non-terminated line. Return it.
	if atEOF {
		return len(data), DropCR(data), nil
	}
	// Request more data.
	return 0, nil, nil
}

// DropCR drops a terminal \r from the data.
func DropCR(data []byte) []byte {
	if len(data) > 0 && data[len(data)-1] == '\r' {
		return data[0 : len(data)-1]
	}
	return data
}
